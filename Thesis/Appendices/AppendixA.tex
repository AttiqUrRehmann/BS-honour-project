% Appendix A

\chapter{R codes for Figures} % Main appendix title

\label{AppendixA} % For referencing this appendix elsewhere, use \ref{AppendixA}

\lhead{Appendix A. \emph{R codes}} % This is for the header on each page - perhaps a shortened title

\lstset{ language=R, basicstyle=\ssmall,  morekeywords={TRUE,FALSE}, keywordstyle=\color{blue}\itshape, commentstyle=\color{DarkGreen} ,stringstyle=\color{DarkGreen}, numbers=left, numberstyle=\ttfamily\color{gray}\footnotesize, stepnumber=1, numbersep=5pt, backgroundcolor=\color{lightgray}, showspaces=false, showstringspaces=false, showtabs=false, frame=single, tabsize=2, captionpos=b, breaklines=true, breakatwhitespace=false, title=\lstname, escapeinside={}, otherkeywords={0,1,2,3,4,5,6,7,8,9}}
%\lstset{% general command to set parameter(s)
%basicstyle=\small, % print whole listing small
%keywordstyle=\color{red}\itshape,
% underlined bold black keywords
%commentstyle=\color{blue}, % white comments
%stringstyle=\ttfamily, % typewriter type for strings
%showstringspaces=false,
%numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, %
%frame=shadowbox,
%rulesepcolor=\color{black},
%,columns=fullflexible
%}
Functions to be used in some Figures R codes. 
\begin{lstlisting}
t.ar1 <-  function(x) { # The function that estimate "t" in case of AR(1)
  n <- nrow(x)          # covariance structure given in equation 3.19. 
  p <- ncol(x)          # We will mention it in a comment wherever it is
  cor.psi <- cor(x)     # required
  sum <- 0
  for(t in 2:p){
    sum <- sum + cor.psi[t,t-1]
  }
  hat.t <- sum/(p-1)
}

t.exch <-  function(x) { # The function that estimate "t" in case of
  n <- nrow(x)           # exchangeable covariance structure given in
  p <- ncol(x)           # equation 3.13. We will mention it in a 
  cc <- cor(x)           # comment wherever it is required
  sum <- 0
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      sum <- sum + cc[i,j]
    }
  }
  hat.t <- 2*sum/(p*(p-1))
}

un.str.cov <- function(n.var, prop.non.zero, const){ # The function to compute the
  AA <- matrix(0, n.var, n.var)      # random covariance structure of Schafer &         
  SS <- matrix(0, n.var, n.var)      # Strimmmer (2004) We will mention it in a
                                     # comment wherever it is required  
  AA[upper.tri(AA)] <- c(rbinom(n.var*(n.var-1)/2,1,prop.non.zero)) # proportion of non-zero elements
  
  BB <- AA + t(AA)
  for (i in 1:(n.var-1)){
    for (j in (i+1):n.var){
      if (AA[i,j]==1){
        SS[i,j] <- runif(1,-1,1) # Replace 1s with random values from the uniform distribution
      }
    }
  }
  
  SS <- SS + t(SS)
  ABS.SS <- abs(SS)
  ColSum <- apply(ABS.SS, 2, sum)
  
  for (i in 1:n.var){
    SS[i,i] <- ColSum[i] + const # fill diagonal entries with column sum plus small positive constant
  }
  
  cov2cor(SS)
}
\end{lstlisting}

Figure \ref{Fig1}.
\begin{lstlisting}
library(MASS) # Library "Modern Applied Statistics with S" abbreviated as MASS must be installed before running these R codes and will be used for all Figures R codes.  
 
# Different sample sizes "n" and fixed "p"
n <- c(25,50,100,1000)
p <- 50

# Null matrix needed for results inside for loop to be used for further analysis
mat <- matrix(NA, nrow=length(n), ncol=p)

# True covariance and its eigenvalues
sigma <- diag(1, nrow = p, ncol = p)
e.tre <- eigen(sigma)$values

# Calculating sample covariance matrix eigenvalues for different samples "n"
for(i in 1:length(n)){
  # Repeat the results 1000 times. We will repeat the results for all Figures in R codes. 
  res <- replicate(1000, {
  # Generating "n * p" X matrix from multivariate normal distribution 
  x <- mvrnorm(n=n[i], mu=rep(0,p), Sigma=sigma)
  # Sample covarince matrix and its eigenvalues
  S <- cov(x)
  S.eigenvalues <- eigen(S)$values
  })
  # Averaging eigenvalues repeated 1000 times
  mat[i,] <- apply(res,1,mean)
}
# y limit for plot
yl <- max(rbind(mat,e.tre))

pdf(file = "screeplot.pdf") 
# plotting true and sample eigenvalues
plot(e.tre,type="b",lwd=3,pch=16, ylim = c(0,yl), xlab="Order", ylab = "Eigenvalues")
points(mat[1,], type="b", lwd=3,pch=16 ,col="red")
points(mat[2,], type="b", lwd=3,pch=16, col="blue")
points(mat[3,], type="b", lwd=3, pch=16,col="5")
points(mat[4,], type="b", lwd=3, pch=16,col="green")

legend("topright",inset = 0.03, legend = c("True","n= 25","n= 50","n= 100","n= 1000"),cex = 1,box.lwd = 2,box.lty = 2,text.font = 4, bg="gray",col = c("black","red","blue","5","green"), lty = 1,  pch = 16)

dev.off()
\end{lstlisting}

Figure (3.1)a
\begin{lstlisting}
library(MASS)

# Various "n" and "p"
n <- c(10, 30, 300)
p <- c(10, 30, 100)

# Null matrix (gamma matrix) needed for gamma values inside for loops to be used for futher analysis
gamma <- matrix(NA, length(n), length(p))
res<- replicate(1000,{
  for(i in 1:length(p)){
    for(j in 1:length(n)){
      # Identity matrix as a true covariance matrix
      sigma <- diag(p[i])
      x <- mvrnorm(n=n[j], mu= rep(0,p[i]), Sigma=sigma)
      
      # Calculate gamma values and store them in null matrix
      gamma[i,j] <- 1/(1+sum(abs(cor(x) - diag(p[i])))/(p[i]))
    }
  }
  gamma
})

# Make the resulting gamma matrix as a vector repeated 1000 times 
vec <- as.vector(res)
# Boxes positions in the boxplot
arr <- as.vector(array(c(1,4,7,2,5,8,3,6,9),dim = c(3,3,1000)))

pdf(file="boxId.pdf")
# Margin
par(mar=c(7,5,1.5,1))
boxplot(vec~arr, outline=FALSE, ylab= expression(gamma), ylim=c(0,1), las=1, xaxt="n",at=c(1,3,5,8,10,12,15,17,19),cex.axis=1.5, cex.lab=1.5)
axis(1, at=c(1,3,5,8,10,12,15,17,19), labels = rep(c(10, 30, 300),3),cex.axis=1.5)
mtext("(a)",at=0.5, line = 0.2, cex= 1.5)
mtext("n =",at=-0.4, line = -28.6, cex= 1.5)
mtext("--",at= 1:5, line = -30, cex= 1.5)
mtext("--",at= 8:12, line = -30, cex= 1.5)
mtext("--",at= 15:19, line = -30, cex= 1.5)
mtext("p =",at= -0.4, line = -31, cex= 1.5)
mtext("10",at= 3, line = -31, cex= 1.5)
mtext("30",at= 10, line = -31, cex= 1.5)
mtext("100",at= 17, line = -31, cex= 1.5)

dev.off()
\end{lstlisting}

Figure (3.1)b
\begin{lstlisting}
library(MASS) 
    # t.ar1 function is required here to estimate "t" 

n <- c(10, 30, 300)
p <- c(10, 30, 100)
t <- 0.5 # True t value for AR(1) covariance structure as a true covariance matrix

gamma <- matrix(NA, 3,3)
res <- replicate(1000,{
  
  for(i in 1:length(p)){
    for(j in 1:length(n)){
      sigma <-  t ^ outer(1:p[i], 1:p[i], function(aa, bb) abs(aa - bb))
      x <- mvrnorm(n=n[j], mu= rep(0,p[i]), Sigma=sigma)
      # Estimate t using t.ar1() function
      t.hat <- t.ar1(x)
      # Estimate true covariance matrix 
      AR1.hat <- t.hat ^ outer(1:p[i], 1:p[i], function(aa, bb) abs(aa - bb)) 
      # Calculate gamma values see section 3.3
      k <- seq(0,p[i]-1)
      gamma[i,j] <- 1/(1+sum(abs(cor(x) - AR1.hat))/(p[i]+sum(2*k*(t.hat)^(p[i]-k))))
    }
  }
  gamma
})
vec <- as.vector(res)
arr <- as.vector(array(c(1,4,7,2,5,8,3,6,9),dim = c(3,3,1000)))

pdf(file="boxAR.pdf")
par(mar=c(7,5,1.5,1))
boxplot(vec~arr, outline=FALSE, ylab= expression(gamma),
        ylim=c(0,1), las=1, xaxt="n", at=c(1,3,5,8,10,12,15,17,19),
        cex.axis=1.5, cex.lab=1.5)
axis(1, at=c(1,3,5,8,10,12,15,17,19), labels = rep(c(10, 30, 300),3),
     cex.axis=1.5)
mtext("(b)",at=0.5, line = 0.2, cex= 1.5)
mtext("n =",at=-0.4, line = -28.6, cex= 1.5)
mtext("--",at= 1:5, line = -30, cex= 1.5)
mtext("--",at= 8:12, line = -30, cex= 1.5)
mtext("--",at= 15:19, line = -30, cex= 1.5)
mtext("p =",at= -0.4, line = -31, cex= 1.5)
mtext("10",at= 3, line = -31, cex= 1.5)
mtext("30",at= 10, line = -31, cex= 1.5)
mtext("100",at= 17, line = -31, cex= 1.5)
dev.off()
\end{lstlisting}

Figure (3.1)c
\begin{lstlisting}
library(MASS)
     # t.exch function is required here to estimate "t"

n <- c(10, 30, 100)
p <- c(10, 30, 80)
t <- 0.5 # True t value for exchangeable covariance structure as a true covariance matrix

gamma <- matrix(NA, 3,3)
res<- replicate(1000,{
  for(i in 1:length(p)){
    for(j in 1:length(n)){
      sigma <- matrix(t,p[i],p[i])
      diag(sigma) = 1
      x <- mvrnorm(n=n[j], mu= rep(0,p[i]), Sigma=sigma)
      # Estimate t value using t.exch() function
      t.hat <- t.exch(x)
      # Estimate true covariance matrix
      hat.exch <- matrix(t.hat,p[i],p[i])
      diag(hat.exch) = 1
      # Calculate gamma values see section 3.3
      gamma[i,j] <- 1/(1+sum(abs(cor(x) - hat.exch))/(p[i]+ (p[i]*(p[i]-1)*t.hat)))
    }
  }
  gamma
})
vec <- as.vector(res)
arr <- as.vector(array(c(1,4,7,2,5,8,3,6,9),dim = c(3,3,1000)))

pdf(file="boxex.pdf")
par(mar=c(7,5,1.5,1))
boxplot(vec~arr, outline=FALSE, ylab= expression(gamma),
        ylim=c(0,1), las=1, xaxt="n", at=c(1,3,5,8,10,12,15,17,19),
        cex.axis=1.5, cex.lab=1.5)
axis(1, at=c(1,3,5,8,10,12,15,17,19), labels = rep(c(10, 30, 300),3),
     cex.axis=1.5)
mtext("(c)",at=0.5, line = 0.2, cex= 1.5)
mtext("n =",at=-0.4, line = -28.6, cex= 1.5)
mtext("--",at= 1:5, line = -30, cex= 1.5)
mtext("--",at= 8:12, line = -30, cex= 1.5)
mtext("--",at= 15:19, line = -30, cex= 1.5)
mtext("p =",at= -0.4, line = -31, cex= 1.5)
mtext("10",at= 3, line = -31, cex= 1.5)
mtext("30",at= 10, line = -31, cex= 1.5)
mtext("100",at= 17, line = -31, cex= 1.5)

dev.off()
\end{lstlisting}

Figure (4.1)a
\begin{lstlisting}
# Comparison of the proposed, shrinkage of Schafer & Strimmer (2005) and maximum likelihood methods sum of absolute errors in estimated eigenvalues.
library(MASS)
library(corpcor) # An R package "correlations and partial correlations" abbreviated as corpcor required for the method of shrinkage estimation of Schafer & Strimmer (2005). We will use this library for the remaining all Figures R codes.
              # t.ar1 function is required here to estimate "t"

p <- c(30, 50 , 100)
n <- 50
t <- 0.5

gamma <- rep(NA,length(p))
ALL.EIGEN <- matrix(NA, length(p), length(p)) # Null matrix for all three competing estimated covariance matrices eigenvalues to be stored in it and use it for further analysis 

res <- replicate(1000,{
  for(i in 1:length(p)) {
    
  sigma <-  t ^ outer(1:p[i], 1:p[i], function(aa, bb) abs(aa - bb))
  e.tre <- eigen(sigma)$values
  x <- mvrnorm(n=n, mu= rep(0,p[i]), Sigma=sigma)
  t.hat <- t.ar1(x)
  # compute target matrix, i.e, AR(1)
  TAR.AR1 <- t.hat ^ outer(1:p[i], 1:p[i], function(aa, bb) abs(aa - bb))
  S <- cor(x)
  # Gamma values needed for the proposed estimator
  k <- seq(0,p[i]-1)
  gamma[i] <- 1/(1+sum(abs(S - TAR.AR1))/(p[i]+sum(2*k*(t.hat)^(p[i]-k))))
  # Proposed estimator
  sigma.gamma <- gamma[i]*S + (1-gamma[i])*TAR.AR1
  
  # Compute eigenvalues of all three competing estimators
  MLA.eigen_values <- eigen(sigma.gamma)$values
  shrink.eigen_values <- eigen(cor.shrink(x,verbose = FALSE))$values
  MLE.eigen_values <- eigen(S)$values
   
  # Compute sum of absolute errors in estimated eigenvalues of all three competing estimators
  sum.eigen.MLA <-  sum(abs(MLA.eigen_values - e.tre ))/sum(e.tre)
  sum.eigen.shrink <- sum(abs(shrink.eigen_values - e.tre ))/sum(e.tre)
  sum.eigen.MLE <- sum(abs(MLE.eigen_values - e.tre ))/sum(e.tre)
  
  # store the resulting sum of absolute errors in estimated eigenvalues of all three competing estimators
  ALL.EIGEN[,i] <- c(sum.eigen.MLA, sum.eigen.shrink, sum.eigen.MLE)
  }
  ALL.EIGEN
})

vec <- as.vector(res)
arr <- as.vector(array(c(1:9),dim = c(3,3,1000)))

pdf(file="FIG4_2a.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
boxplot(vec~arr, outline=FALSE, ylab= expression(sum(abs(hat(lambda[i]) - lambda[i]))/sum(lambda[i])),
        ylim=c(0,1), las=2, xaxt="n",at=c(1,2,3,5,6,7,9,10,11),
        cex.axis=2, cex.lab=2, col=c("red","green", "blue"))
mtext("(a)", side = 3, line = 0.5, cex = 2)
mtext("30",at=2, line = -29, cex= 2)
mtext("50",at=6, line = -29, cex= 2)
mtext("100",at=10, line = -29, cex= 2)
mtext("p",at=6, line = -31, cex= 2)

legend("topleft", legend = c("MLA","Shrinkage","MLE"),cex = 1.5,box.lwd = 2,box.lty = 1,
       text.font = 3,col = c("red","green", "blue"), pch = 15)
dev.off()
\end{lstlisting}

Figure (4.1)b
\begin{lstlisting}
# Comparison of the proposed, shrinkage of Schafer & Strimmer (2005) and maximum likelihood methods sum of absolute errors in estimated eigenvalues.
library(MASS)
library(corpcor)
        # t.ar1 function is required here to estimate "t"

p <- c(30, 50 , 100)
n <- 50
t <- 0.5

gamma <- rep(NA,length(p))
ALL.EIGEN <- matrix(NA, length(p), length(p))

res <- replicate(1000,{
  for(i in 1:length(p)) {
    sigma <- diag(p[i]) # Identity as a true covariance matrix
    e.tre <- eigen(sigma)$values
    x <- mvrnorm(n=n, mu= rep(0,p[i]), Sigma=sigma)
    # AR(1) as a target matrix
    # compute target matrix
    t.hat <- t.ar1(x)
    TAR.AR1 <- t.hat ^ outer(1:p[i], 1:p[i], function(aa, bb) abs(aa - bb))
    S <- cor(x)
    k <- seq(0,p[i]-1)
    # Gamma values for the proposed method
    gamma[i] <- 1/(1+sum(abs(S - TAR.AR1))/(p[i]+sum(2*k*(t.hat)^(p[i]-k))))
    # Compute proposed estimator
    sigma.gamma <- gamma[i]*cor(x) + (1-gamma[i])*TAR.AR1
    
    # Compute eigenvalues of all three competing estimators
    MLA.eigen_values <- eigen(sigma.gamma)$values
    shrink.eigen_values <- eigen(cor.shrink(x,verbose = FALSE))$values
    MLE.eigen_values <- eigen(S)$values
    
    # Compute sum of absolute errors in estimated eigenvalues of all three competing estimators
    sum.eigen.MLA <-  sum(abs(MLA.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.shrink <- sum(abs(shrink.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.MLE <- sum(abs(MLE.eigen_values - e.tre ))/sum(e.tre)
    
    ALL.EIGEN[,i] <- c(sum.eigen.MLA, sum.eigen.shrink, sum.eigen.MLE)
    
    }
  ALL.EIGEN
})

vec <- as.vector(res)
arr <- as.vector(array(c(1:9),dim = c(3,3,1000)))

pdf(file="FIG4_2b.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
boxplot(vec~arr, outline=FALSE, ylab= expression(sum(abs(hat(lambda[i]) - lambda[i]))/sum(lambda[i])),
        ylim=c(0,1.2), las=2, xaxt="n",at=c(1,2,3,5,6,7,9,10,11),
        cex.axis=2, cex.lab=2, col=c("red","green", "blue"))
mtext("(b)", side = 3, line = 0.5, cex = 2)
mtext("30",at=2, line = -29, cex= 2)
mtext("50",at=6, line = -29, cex= 2)
mtext("100",at=10, line = -29, cex= 2)
mtext("p",at=6, line = -31, cex= 2)

legend("topleft", legend = c("MLA","Shrinkage","MLE"),cex = 1.5,box.lwd = 2,box.lty = 1,
       text.font = 3,col = c("red","green", "blue"), pch = 15)
dev.off()
\end{lstlisting}

Figure (4.1)c
\begin{lstlisting}
# Comparison of the proposed, shrinkage of Schafer & Strimmer (2005) and maximum likelihood methods sum of absolute errors in estimated eigenvalues.
library(MASS)
library(corpcor)
          # t.exch function is required here to estimate "t"
 
p <- c(30, 50 , 100)
n <- 50
t <- 0.5

gamma <- rep(NA,length(p))
ALL.EIGEN <- matrix(NA, length(p), length(p))

res <- replicate(1000,{
  
  for(i in 1:length(p)) {
    
    sigma <-  matrix(t, p[i], p[i])
    diag(sigma) = 1
    e.tre <- eigen(sigma)$values
    x <- mvrnorm(n=n, mu= rep(0,p[i]), Sigma=sigma)
    # Exchangeable as a target matrix
    # compute target matrix
    t.hat <- t.exch(x)
    TAR.EXCH <- matrix(t.hat, p[i], p[i])
    diag(TAR.EXCH) = 1
    S <- cor(x)
    
    # Gamma values for the proposed method
    gamma[i] <- 1/(1+sum(abs(S - TAR.EXCH))/(p[i] + (p[i]*(p[i]-1)*t.hat)))
    # Compute proposed estimator
    sigma.gamma <- gamma[i]*S + (1-gamma[i])*TAR.EXCH
    
    # Compute eigenvalues of all three competing estimators
    MLA.eigen_values <- eigen(sigma.gamma)$values
    shrink.eigen_values <- eigen(cor.shrink(x,verbose = FALSE))$values
    MLE.eigen_values <- eigen(S)$values
    
    # Compute sum of absolute errors in estimated eigenvalues of all three competing estimators
    sum.eigen.MLA <-  sum(abs(MLA.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.shrink <- sum(abs(shrink.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.MLE <- sum(abs(MLE.eigen_values - e.tre ))/sum(e.tre)
    
    ALL.EIGEN[,i] <- c(sum.eigen.MLA, sum.eigen.shrink, sum.eigen.MLE)
  }
  ALL.EIGEN
})

vec <- as.vector(res)
arr <- as.vector(array(c(1:9),dim = c(3,3,1000)))

pdf(file="FIG4_2c.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
boxplot(vec~arr, outline=FALSE, ylab= expression(sum(abs(hat(lambda[i]) - lambda[i]))/sum(lambda[i])),
        ylim=c(0,1), las=2, xaxt="n",at=c(1,2,3,5,6,7,9,10,11),
        cex.axis=2, cex.lab=2, col=c("red","green", "blue"))
mtext("(c)", side = 3, line = 0.5, cex = 2)
mtext("30",at=2, line = -29, cex= 2)
mtext("50",at=6, line = -29, cex= 2)
mtext("100",at=10, line = -29, cex= 2)
mtext("p",at=6, line = -31, cex= 2)

legend("topleft", legend = c("MLA","Shrinkage","MLE"),cex = 1.5,box.lwd = 2,box.lty = 1,
       text.font = 3,col = c("red","green", "blue"), pch = 15)
dev.off()
\end{lstlisting}

Figure (4.1)d
\begin{lstlisting}
# Comparison of the proposed, shrinkage of Schafer & Strimmer (2005) and maximum likelihood methods sum of absolute errors in estimated eigenvalues.
library(MASS)
library(corpcor)
          # t.exch function is required here to estimate "t"

p <- c(30, 50 , 100)
n <- 50
t <- 0.5

gamma <- rep(NA,length(p))
ALL.EIGEN <- matrix(NA, length(p), length(p))

res <- replicate(1000,{
  for(i in 1:length(p)) {
    # Identity as a true covariance matrix
    sigma <- diag(p[i])
    e.tre <- eigen(sigma)$values
    x <- mvrnorm(n=n, mu= rep(0,p[i]), Sigma=sigma)
    # Exchangeable as a target matrix
    # compute target matrix
    t.hat <- t.exch(x)
    TAR.EXCH <- matrix(t.hat, p[i], p[i])
    diag(TAR.EXCH) = 1
    S <- cor(x)
    # Gamma values for the proposed method
    gamma[i] <- 1/(1+sum(abs(S - TAR.EXCH))/(p[i] + (p[i]*(p[i]-1)*t.hat)))
    # Compute proposed estimator
    sigma.gamma <- gamma[i]*S + (1-gamma[i])*TAR.EXCH
    
    # Compute eigenvalues of all three competing estimators
    MLA.eigen_values <- eigen(sigma.gamma)$values
    shrink.eigen_values <- eigen(cor.shrink(x,verbose = FALSE))$values
    MLE.eigen_values <- eigen(S)$values
    
    # Compute sum of absolute errors in estimated eigenvalues of all three competing estimators
    sum.eigen.MLA <-  sum(abs(MLA.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.shrink <- sum(abs(shrink.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.MLE <- sum(abs(MLE.eigen_values - e.tre ))/sum(e.tre)
    
    ALL.EIGEN[,i] <- c(sum.eigen.MLA, sum.eigen.shrink, sum.eigen.MLE)
  }
  ALL.EIGEN
})


vec <- as.vector(res)
arr <- as.vector(array(c(1:9),dim = c(3,3,1000)))

pdf(file="FIG4_2d.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
boxplot(vec~arr, outline=FALSE, ylab= expression(sum(abs(hat(lambda[i]) - lambda[i]))/sum(lambda[i])),
        ylim=c(0,1.2), las=2, xaxt="n",at=c(1,2,3,5,6,7,9,10,11),
        cex.axis=2, cex.lab=2, col=c("red","green", "blue"))
mtext("(d)", side = 3, line = 0.5, cex = 2)
mtext("30",at=2, line = -29, cex= 2)
mtext("50",at=6, line = -29, cex= 2)
mtext("100",at=10, line = -29, cex= 2)
mtext("p",at=6, line = -31, cex= 2)

legend("topleft", legend = c("MLA","Shrinkage","MLE"),cex = 1.5,box.lwd = 2,box.lty = 1,
       text.font = 3,col = c("red","green", "blue"), pch = 15)
dev.off()
\end{lstlisting}

Figure (4.1)e
\begin{lstlisting}
# Comparison of the proposed, shrinkage of Schafer & Strimmer (2005) and maximum likelihood methods sum of absolute errors in estimated eigenvalues.
library(MASS)
library(corpcor)
           # Function of random covariance structure is required here

p <- n.var <- c(30, 50 , 100)
n <- 50

gamma <- rep(NA,length(p))
ALL.EIGEN <- matrix(NA, length(p), length(p))

res <- replicate(1000,{
  for(i in 1:length(p)) {
    prop.non.zero <- 0.3
    const <- 0.01
    # random covariance structure as a ture covariance matrix 
    sigma <- un.str.cov(n.var[i], prop.non.zero, const)
    e.tre <- eigen(sigma)$values
    x <- mvrnorm(n=n, mu= rep(0,p[i]), Sigma=sigma)
    S <- cor(x)
    
    # Compute gamma values using Identity as a target
    gamma[i] <- 1/(1+sum(abs(S - diag(p[i])))/(p[i]))
    # Compute proposed estimator
    sigma.gamma <- gamma[i]*S + (1-gamma[i])*diag(p[i])
    
    # Compute eigenvalues of all three competing estimators
    MLA.eigen_values <- eigen(sigma.gamma)$values
    shrink.eigen_values <- eigen(cor.shrink(x,verbose = FALSE))$values
    MLE.eigen_values <- eigen(S)$values
    
    # Compute sum of absolute errors in estimated eigenvalues of all three competing estimators
    sum.eigen.MLA <-  sum(abs(MLA.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.shrink <- sum(abs(shrink.eigen_values - e.tre ))/sum(e.tre)
    sum.eigen.MLE <- sum(abs(MLE.eigen_values - e.tre ))/sum(e.tre)
    
    ALL.EIGEN[,i] <- c(sum.eigen.MLA, sum.eigen.shrink, sum.eigen.MLE)
  }
  ALL.EIGEN
})

vec <- as.vector(res)
arr <- as.vector(array(c(1:9),dim = c(3,3,1000)))

pdf(file="FIG4_2e.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
boxplot(vec~arr, outline=FALSE, ylab= expression(sum(abs(hat(lambda[i]) - lambda[i]))/sum(lambda[i])),
        ylim=c(0,1), las=2, xaxt="n",at=c(1,2,3,5,6,7,9,10,11),
        cex.axis=2, cex.lab=2, col=c("red","green", "blue"))
mtext("(e)", side = 3, line = 0.5, cex = 2)
mtext("30",at=2, line = -29, cex= 2)
mtext("50",at=6, line = -29, cex= 2)
mtext("100",at=10, line = -29, cex= 2)
mtext("p",at=6, line = -31, cex= 2)

legend("topleft", legend = c("MLA","Shrinkage","MLE"),cex = 1.5,box.lwd = 2,box.lty = 1,
       text.font = 3,col = c("red","green", "blue"), pch = 15)
dev.off()
\end{lstlisting}

Figure (4.2)a
\begin{lstlisting}
# Comparison of MSE of all three competing procedures: Proposed, shrinkage and maximum likelihood     method 
library(MASS)
library(corpcor)
              # t.ar1 function is required here to estimate "t"

p <- n.var <- 10
n <- c(10, 20,30,40,50,60,70,90,120,200)
t <- 0.5
sigma <-  t ^ outer(1:p, 1:p, function(aa, bb) abs(aa - bb)) # true covariance matrix AR(1)
gamma <- rep(NA, length(n))
MSE <- matrix(NA, 3, length(n)) # Null matrix for the MSE of all three competing procedures to be store in it and use for further analysis

res <- replicate(1000,{
  for(i in 1:length(n)) {
  x <- mvrnorm(n=n[i], mu= rep(0,p), Sigma=sigma)
  # Compute target matrix, i.e, AR(1)
  t.hat <- t.ar1(x)
  TAR.AR1 <- t.hat ^ outer(1:p, 1:p, function(aa, bb) abs(aa - bb))
  S <- cor(x)
  
  # Compute gamma for the proposed estimator
  k <- seq(0,p-1)
  gamma[i] <- 1/(1+sum(abs(S - TAR.AR1))/(p+sum(2*k*(t.hat)^(p-k))))
  # Compute proposed estimator of the covariance matrix
  sigma.gamma = gamma[i]*S + (1-gamma[i])*TAR.AR1
  # Compute shrinkage estimator of the covariance matrix
  sigma.shrink <- cor.shrink(x,verbose = FALSE)
  
  # Compute the MSE of all three estimators
  MSE_OF_MLE <- sum((S - sigma)^2)
  MSE_OF_SIGMA.GAMMA <- sum((sigma.gamma - sigma)^2)
  MSE_OF_SIGMA.SHRINK <- sum((sigma.shrink - sigma)^2)
  
  # Store the resulting MSE in the null matrix
  MSE[,i] <- c(MSE_OF_MLE,MSE_OF_SIGMA.GAMMA,MSE_OF_SIGMA.SHRINK)
  }
  MSE
})
# Average the MSE repeated 1000 times
ave_MSE <- apply(res, c(1,2), mean)

y.min <- min(ave_MSE)
y.max <- max(ave_MSE)

pdf(file="FIG4_4a.pdf")
par(mar=c(6,6,2,1), mgp = c(4,1,0))
plot(ave_MSE[1,], type="b",lwd=3,pch=1,ylim = c(y.min,y.max),
     cex.lab=2, ylab = "MSE", xlab = "",las=2, xaxt='n',
     cex.axis=2, col=20)
axis(1, at=c(1,2,3,4,5,6,7,8,9,10),
     labels = c(10, 20,30,40,50,60,70,90,120,200),
     cex.axis=1.3)
mtext("n",at=6, line = -31, cex= 2)
points(ave_MSE[2,], type="b", lwd=3,pch=1 ,col= "red")
points(ave_MSE[3,], type="b", lwd=3,pch=1 ,col= "green")
mtext("(a)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("red", "green", 20),
       lwd=3, lty = 1, pch = 1)
dev.off()
\end{lstlisting}

Figure (4.2)b
\begin{lstlisting}
# Comparison of MSE of all three competing procedures: Proposed, shrinkage and maximum likelihood     method 
library(MASS)
library(corpcor)
              # t.ar1 function is required here to estimate "t"

p <- n.var <- 10
n <- c(10, 20,30,40,50,60,70,90,120,200)
t <- 0.5
sigma <- diag(p) # Identity as a true covariance matrix
gamma <- rep(NA, length(n))
MSE <- matrix(NA, 3, length(n))

res <- replicate(1000,{
  for(i in 1:length(n)) {
    x <- mvrnorm(n=n[i], mu= rep(0,p), Sigma=sigma)
    # Compute target matrix, i.e, AR(1)
    t.hat <- t.ar1(x)
    # Compute the target matrix, i.e, AR(1)
    TAR.AR1 <- t.hat ^ outer(1:p, 1:p, function(aa, bb) abs(aa - bb))
    S <- cor(x)
    
    k <- seq(0,p-1)
    # Compute gamma for the proposed estimator
    gamma[i] <- 1/(1+sum(abs(S - TAR.AR1))/(p+sum(2*k*(t.hat)^(p-k))))
    # Compute proposed estimator of the covariance matrix
    sigma.gamma = gamma[i]*S + (1-gamma[i])*TAR.AR1
    # Compute shrinkage estimator of the covariance matrix
    sigma.shrink <- cor.shrink(x,verbose = FALSE)
    
    # Compute the MSE of all three competing estimators
    MSE_OF_MLE <- sum((S - sigma)^2)
    MSE_OF_SIGMA.GAMMA <- sum((sigma.gamma - sigma)^2)
    MSE_OF_SIGMA.SHRINK <- sum((sigma.shrink - sigma)^2)
    
    # Store the resulting MSE in the null matrix
    MSE[,i] <-  c(MSE_OF_MLE,MSE_OF_SIGMA.GAMMA,MSE_OF_SIGMA.SHRINK)
  }
  MSE
})
# Average the MSE repeated 1000 times
ave_MSE <- apply(res, c(1,2), mean)
y.min <- min(ave_MSE)
y.max <- max(ave_MSE)

pdf(file="FIG4_4b.pdf")
par(mar=c(6,7,2,1), mgp = c(5,1,0))
plot(ave_MSE[1,], type="b",lwd=3,pch=1,ylim = c(y.min,y.max),
     cex.lab=2, ylab = "MSE", xlab = "",las=2, xaxt='n',
     cex.axis=2, col=20)
axis(1, at=c(1,2,3,4,5,6,7,8,9,10),
     labels = c(10, 20,30,40,50,60,70,90,120,200),
     cex.axis=1.2)
points(ave_MSE[2,], type="b", lwd=3,pch=1 ,col= "red")
points(ave_MSE[3,], type="b", lwd=3,pch=1 ,col= "green")
mtext("n",at=6, line = -31, cex= 2)
mtext("(b)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("red", "green", 20),
       lwd=3, lty = 1, pch = 1)
dev.off()
\end{lstlisting}

Figure (4.2)c
\begin{lstlisting}
# Comparison of MSE of all three competing procedures: Proposed, shrinkage and maximum likelihood     method
library(MASS)
library(corpcor)
                # t.exch function is required here to estimate "t"

p <- n.var <- 10
n <- c(10, 20,30,40,50,60,70,90,120,200)
t <- 0.5
sigma <-  matrix(t, p, p) # Exchangeable covariance structure as a true covariance matrix
diag(sigma) = 1
gamma <- rep(NA, length(n))
MSE <- matrix(NA, 3, length(n))

res <- replicate(1000,{
  for(i in 1:length(n)) {
    x <- mvrnorm(n=n[i], mu= rep(0,p), Sigma=sigma)
    # Compute the target matrix, i.e, exchangeable
    t.hat <- t.exch(x)
    TAR.EXCH <- matrix(t.hat, p, p)
    diag(TAR.EXCH) = 1
    S <- cor(x)
    
    # Compute the gamma values for the proposed method
    gamma[i] <- 1/(1+sum(abs(S - TAR.EXCH))/(p + (p*(p-1)*t.hat)))
    # Compute proposed estimator of the covariance matrix 
    sigma.gamma <- gamma[i]*S + (1-gamma[i])*TAR.EXCH
    # Compute shrinkage estimator of the covariance matrix
    sigma.shrink <- cor.shrink(x,verbose = FALSE)
    
    # Computing MSE for all three competing estimators    
    MSE_OF_MLE <- sum((S - sigma)^2)
    MSE_OF_SIGMA.GAMMA <- sum((sigma.gamma - sigma)^2)
    MSE_OF_SIGMA.SHRINK <- sum((sigma.shrink - sigma)^2)
    
    MSE[,i] <- c(MSE_OF_MLE,MSE_OF_SIGMA.GAMMA,MSE_OF_SIGMA.SHRINK)
  }
  MSE
})
# Average the resulting MSE repeated 1000 times 
ave_MSE <- apply(res, c(1,2), mean)
y.min <- min(ave_MSE)
y.max <- max(ave_MSE)

pdf(file="FIG4_4c.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
plot(ave_MSE[1,], type="b",lwd=3,pch=1,ylim = c(y.min,y.max),
     cex.lab=2, ylab = "MSE", xlab = "",las=2, xaxt='n',
     cex.axis=2, col=20)
axis(1, at=c(1,2,3,4,5,6,7,8,9,10),
     labels = c(10, 20,30,40,50,60,70,90,120,200),
     cex.axis=1.2)
mtext("n",at=6, line = -31, cex= 2)
points(ave_MSE[2,], type="b", lwd=3,pch=1 ,col= "red")
points(ave_MSE[3,], type="b", lwd=3,pch=1 ,col= "green")
mtext("(c)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("red", "green", 20),
       lwd=3, lty = 1, pch = 1)
dev.off()
\end{lstlisting}

Figure (4.2)d
\begin{lstlisting}
# Comparison of MSE of all three competing procedures: Proposed, shrinkage and maximum likelihood     method
library(MASS)
library(corpcor)
            # t.exch function is required here to estimate "t"

p <- n.var <- 10
n <- c(10, 20,30,40,50,60,70,90,120,200)
t <- 0.5
sigma <-  diag(p) # Identity as a true covariance matrix
gamma <- rep(NA, length(n))
MSE <- matrix(NA, 3, length(n))

res <- replicate(1000,{
  for(i in 1:length(n)) {
    x <- mvrnorm(n=n[i], mu= rep(0,p), Sigma=sigma)
    # Compute target matrix, i.e, exchangeable
    t.hat <- t.exch(x)
    TAR.EXCH <- matrix(t.hat, p, p)
    diag(TAR.EXCH) = 1
    S <- cor(x)
    
    # Calculate gamma values for the proposed estimator
    gamma[i] <- 1/(1+sum(abs(S - TAR.EXCH))/(p + (p*(p-1)*t.hat)))
    # Calculate proposed and shrinkage estimator
    sigma.gamma <- gamma[i]*S + (1-gamma[i])*TAR.EXCH
    sigma.shrink <- cor.shrink(x,verbose = FALSE)
    
    # Calculate MSE of all three competing procedures
    MSE_OF_MLE <- sum((S - sigma)^2)
    MSE_OF_SIGMA.GAMMA <- sum((sigma.gamma - sigma)^2)
    MSE_OF_SIGMA.SHRINK <- sum((sigma.shrink - sigma)^2)
    
    MSE[,i] <- c(MSE_OF_MLE,MSE_OF_SIGMA.GAMMA,MSE_OF_SIGMA.SHRINK)
  }
  MSE
})
# Average the resulting MSE over 1000 simulations
ave_MSE <- apply(res, c(1,2), mean)
y.min <- min(ave_MSE)
y.max <- max(ave_MSE)

pdf(file="FIG4_4d.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
plot(ave_MSE[1,], type="b",lwd=3,pch=1,ylim = c(y.min,y.max),
     cex.lab=2, ylab = "MSE", xlab = "",las=2, xaxt='n',
     cex.axis=2, col=20)
axis(1, at=c(1,2,3,4,5,6,7,8,9,10),
     labels = c(10, 20,30,40,50,60,70,90,120,200),
     cex.axis=1.2)
mtext("n",at=6, line = -31, cex= 2)
points(ave_MSE[2,], type="b", lwd=3,pch=1 ,col= "red")
points(ave_MSE[3,], type="b", lwd=3,pch=1 ,col= "green")
mtext("(d)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("red", "green", 20),
       lwd=3, lty = 1, pch = 1)
dev.off()
\end{lstlisting}

Figure (4.2)e
\begin{lstlisting}
# Comparison of MSE of all three competing procedures: Proposed, shrinkage and maximum likelihood     method
library(MASS)
library(corpcor)
                # Function of random covariance structure is required here

p <- n.var <- 10
n <- c(10, 20,30,40,50,60,70,90,120,200)

gamma <- rep(NA, length(n))
MSE <- matrix(NA, 3, length(n))

prop.non.zero <- 0.3
const <- 0.01
sigma <- un.str.cov(n.var, prop.non.zero, const) # Random covariance structure as a true covariance matrix

res <- replicate(1000,{
  for(i in 1:length(n)) {
    x <- mvrnorm(n=n[i], mu= rep(0,p), Sigma=sigma)
    S <- cor(x)
    
    # Calculate gamma values for the proposed estimator
    gamma[i] <- 1/(1+sum(abs(S - diag(p)))/(p))
    # Calculate proposed and shrinkage estimator 
    sigma.gamma <- gamma[i]*S + (1-gamma[i])*diag(p)
    sigma.shrink <- cor.shrink(x,verbose = FALSE)
    
    # Calculate MSE of all three competing procedures
    MSE_OF_MLE <- sum((S - sigma)^2)
    MSE_OF_SIGMA.GAMMA <- sum((sigma.gamma - sigma)^2)
    MSE_OF_SIGMA.SHRINK <- sum((sigma.shrink - sigma)^2)
    
    MSE[,i] <-  c(MSE_OF_MLE,MSE_OF_SIGMA.GAMMA,MSE_OF_SIGMA.SHRINK)
    
  }
  MSE
})
# Average the resulting MSE over 1000 simulations
ave_MSE <- apply(res, c(1,2), mean)
y.min <- min(ave_MSE)
y.max <- max(ave_MSE)

pdf(file="FIG4_4e.pdf")
par(mar=c(6,7,2,1), mgp = c(4,1,0))
plot(ave_MSE[1,], type="b",lwd=3,pch=1,ylim = c(y.min,y.max),
     cex.lab=2, ylab = "MSE", xlab = "",las=2, xaxt='n',
     cex.axis=2, col=20)
axis(1, at=c(1,2,3,4,5,6,7,8,9,10),
     labels = c(10, 20,30,40,50,60,70,90,120,200),
     cex.axis=1.2)
mtext("n",at=6, line = -31, cex= 2)
points(ave_MSE[2,], type="b", lwd=3,pch=1 ,col= "red")
points(ave_MSE[3,], type="b", lwd=3,pch=1 ,col= "green")
mtext("(e)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("red", "green", 20),
       lwd=3, lty = 1, pch = 1)
dev.off()
\end{lstlisting}

Figure (4.3)a
\begin{lstlisting}
# Comparison of eigenvalues of the proposed, shrinkage and maximum likelihood method along with the eigenvalues of true covariance matrix 
library(MASS)
library(corpcor)
               # t.ar1 function is required here to estimate "t"

p <- n.var <- 50
n <- 30
t <- 0.5
sigma <-  t ^ outer(1:p, 1:p, function(aa, bb) abs(aa - bb))
e.tre <- eigen(sigma)$values

eigen.matrix <- matrix(NA,3,n.var) # null matrix for the eigenvalues to be store in it.

res <- replicate(1000,{
  x <- mvrnorm(n=n, mu= rep(0,p), Sigma=sigma)
  # Calculate target matrix, i.e, AR(1)
  t.hat <- t.ar1(x)
  TAR.AR1 <- t.hat ^ outer(1:p, 1:p, function(aa, bb) abs(aa - bb))
  S <- cor(x)
  
  # Calculate gamma values for the proposed method
  k <- seq(0,p-1)
  gamma <- 1/(1+sum(abs(S - TAR.AR1))/(p+sum(2*k*(t.hat)^(p-k))))
  
  # Calculate the proposed estimator
  sigma.gamma = gamma*S + (1-gamma)*TAR.AR1
  
  # Calculate the eigenvalues of all three competing procedures
  MLA.eigen_values <- eigen(sigma.gamma)$values
  eigen_values.shrink <- eigen(cor.shrink(x,verbose = FALSE))$values
  MLE.eigen_values <- eigen(S)$values
  
  # Store the resulting eigenvalues in the null matrix
  eigen.matrix[1,] <- MLE.eigen_values
  eigen.matrix[2,] <- MLA.eigen_values
  eigen.matrix[3,] <- eigen_values.shrink
  eigen.matrix
})
# Average the resulting eigenvalues over 1000 simulations
ave_eigen <- apply(res, c(1,2), mean)
yl <- max(rbind(ave_eigen, e.tre))

pdf(file="FIG4_3a.pdf")
par(mar=c(7,6,2,1), mgp = c(4,1,0))
plot(e.tre, type="b",lwd=3,pch=16,ylim = c(0,yl), xlab="Order",
     ylab = "Eigenvalues", cex.axis=2, yaxt="n", cex.lab=2)
axis(2, las=2, cex.axis=2)
points(ave_eigen[1,], type="b", lwd=3,pch=16 ,col= "20")
points(ave_eigen[2,], type="b", lwd=3,pch=16 ,col= "red")
points(ave_eigen[3,], type="b", lwd=3,pch=16 ,col= "green")
mtext("(a)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("True", "MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("black","red", "green", 20),
       lty = 1, pch = 16)
dev.off()
\end{lstlisting}

Figure (4.3)b
\begin{lstlisting}
library(MASS)
library(corpcor)
               # t.ar1 function is required here to estimate "t"              
              
p <- n.var <- 50
n <- 30
t <- 0.5

sigma <-  diag(p) # Identity as a true covariance matrix
e.tre <- eigen(sigma)$values
eigen.matrix <- matrix(NA,3,n.var)

res <- replicate(1000,{
  x <- mvrnorm(n=n, mu= rep(0,p), Sigma=sigma)
  # Calculate target matrix, i.e, AR(1)
  t.hat <- t.ar1(x)
  TAR.AR1 <- t.hat ^ outer(1:p, 1:p, function(aa, bb) abs(aa - bb))
  S <- cor(x)
  
  # Calculate gamma values for the proposed method
  k <- seq(0,p-1)
  gamma <- 1/(1+sum(abs(S - TAR.AR1))/(p+sum(2*k*(t.hat)^(p-k))))
  # Calculate the proposed estimator of the true covariance matrix
  sigma.gamma = gamma*S + (1-gamma)*TAR.AR1
  
  # Calculate the eigenvalues of all three proposed estimators
  MLA.eigen_values <- eigen(sigma.gamma)$values
  eigen_values.shrink <- eigen(cor.shrink(x,verbose = FALSE))$values
  MLE.eigen_values <- eigen(S)$values
  
  # Store the eigenvalues in the null matrix
  eigen.matrix[1,] <- MLE.eigen_values
  eigen.matrix[2,] <- MLA.eigen_values
  eigen.matrix[3,] <- eigen_values.shrink
  eigen.matrix
})
# Average the resulting eigenvalue repeated 1000 times
ave_eigen <- apply(res, c(1,2), mean)
yl <- max(rbind(ave_eigen, e.tre))

pdf(file="FIG4_3b.pdf")
par(mar=c(7,6,2,1), mgp = c(4,1,0))
plot(e.tre, type="b",lwd=3,pch=16,ylim = c(0,yl), xlab="Order",
     ylab = "Eigenvalues", cex.axis=2, yaxt="n", cex.lab=2)
axis(2, las=2, cex.axis=2)
points(ave_eigen[1,], type="b", lwd=3,pch=16 ,col= "20")
points(ave_eigen[2,], type="b", lwd=3,pch=16 ,col= "red")
points(ave_eigen[3,], type="b", lwd=3,pch=16 ,col= "green")
mtext("(b)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("True", "MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("black","red", "green", 20),
       lty = 1, pch = 16)
dev.off()
\end{lstlisting}

Figure (4.3)c
\begin{lstlisting}
library(MASS)
library(corpcor)

# t.exch function is required here to estimate "t"

p <- n.var <- 50
n <- 30
t <- 0.3
sigma <-  matrix(t, p, p) # Exchangeable covariance structure as a true covariance matrix
diag(sigma) = 1
e.tre <- eigen(sigma)$values

eigen.matrix <- matrix(NA,3,n.var)
x <- mvrnorm(n=n, mu= rep(0,p), Sigma=sigma)

res <- replicate(1000,{
  # Calculate the target matrix, i.e, exchangeable
  t.hat <- t.exch(x)
  TAR.EXCH <- matrix(t.hat, p, p)
  diag(TAR.EXCH) = 1
  S <- cor(x)
  
  # Calculate the gamma values for the proposed method
  gamma <- 1/(1+sum(abs(S - TAR.EXCH))/(p + (p*(p-1)*t.hat)))
  # Calculate the proposed estimator 
  sigma.gamma = gamma*S + (1-gamma)*TAR.EXCH
  
  # calculate the eigenvalues of all three competing procedures
  MLA.eigen_values <- eigen(sigma.gamma)$values
  eigen_values.shrink <- eigen(cor.shrink(x,verbose = FALSE))$values
  MLE.eigen_values <- eigen(S)$values
  
  # Store the resulting eigenvalues in the null matrix 
  eigen.matrix[1,] <- MLE.eigen_values
  eigen.matrix[2,] <- MLA.eigen_values
  eigen.matrix[3,] <- eigen_values.shrink
  eigen.matrix
})
# Average the resulting eigenvalues repeated 1000 times
ave_eigen <- apply(res, c(1,2), mean)
yl <- max(rbind(ave_eigen, e.tre))

pdf(file="FIG4_3c.pdf")
par(mar=c(7,6,2,1), mgp = c(4,1,0))
plot(e.tre, type="b",lwd=3,pch=16,ylim = c(0,yl), xlab="Order",
     ylab = "Eigenvalues", cex.axis=2, yaxt="n", cex.lab=2)
axis(2, las=2, cex.axis=2)
points(ave_eigen[1,], type="b", lwd=3,pch=16 ,col= "20")
points(ave_eigen[2,], type="b", lwd=3,pch=16 ,col= "red")
points(ave_eigen[3,], type="b", lwd=3,pch=16 ,col= "green")
mtext("(c)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("True", "MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("black","red", "green", 20),
       lty = 1, pch = 16)
dev.off()
\end{lstlisting}

Figure (4.3)d
\begin{lstlisting}
library(MASS)
library(corpcor)
               # t.exch function is required here to estimate "t"

p <- n.var <- 50
n <- 30
t <- 0.3
sigma <-  diag(p) # Identity as a true covariance matrix
e.tre <- eigen(sigma)$values

eigen.matrix <- matrix(NA,3,n.var)

res <- replicate(1000,{
  x <- mvrnorm(n=n, mu= rep(0,p), Sigma=sigma)
  # Calculate target matrix, i.e, exchangeable covariance structure
  t.hat <- t.exch(x)
  TAR.EXCH <- matrix(t.hat, p, p)
  diag(TAR.EXCH) = 1
  S <- cor(x)
  
  # Calculate gamma values for the proposed method
  gamma <- 1/(1+sum(abs(S - TAR.EXCH))/(p + (p*(p-1)*t.hat)))
  # Calculate the proposed estimator
  sigma.gamma = gamma*S + (1-gamma)*TAR.EXCH
  
  # Calculate the eigenvalues of all the competing estimators of the true covariance matrix
  MLA.eigen_values <- eigen(sigma.gamma)$values
  eigen_values.shrink <- eigen(cor.shrink(x,verbose = FALSE))$values
  MLE.eigen_values <- eigen(S)$values
  
  eigen.matrix[1,] <- MLE.eigen_values
  eigen.matrix[2,] <- MLA.eigen_values
  eigen.matrix[3,] <- eigen_values.shrink
  eigen.matrix
})
# Average the resulting eigenvalues simulated 1000 times 
ave_eigen <- apply(res, c(1,2), mean)
yl <- max(rbind(ave_eigen, e.tre))

pdf(file="FIG4_3d.pdf")
par(mar=c(7,6,2,1), mgp = c(4,1,0))
plot(e.tre, type="b",lwd=3,pch=16,ylim = c(0,yl), xlab="Order",
     ylab = "Eigenvalues", cex.axis=2, yaxt="n", cex.lab=2)
axis(2, las=2, cex.axis=2)
points(ave_eigen[1,], type="b", lwd=3,pch=16 ,col= "20")
points(ave_eigen[2,], type="b", lwd=3,pch=16 ,col= "red")
points(ave_eigen[3,], type="b", lwd=3,pch=16 ,col= "green")
mtext("(d)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("True", "MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("black","red", "green", 20),
       lty = 1, pch = 16)
dev.off()
\end{lstlisting}

Figure (4.3)e
\begin{lstlisting}
library(MASS)
library(corpcor)
               # Function of random covariance structure is required here

n.var <- 50
n <- 30
prop.non.zero <- 0.30
const <- 0.01
sigma <- un.str.cov(n.var, prop.non.zero, const) # random covariance structure as a true covariance matrix

e.tre <- eigen(sigma)$values
eigen.matrix <- matrix(NA,3,n.var)

res <- replicate(1000,{
  x <- mvrnorm(n=n, mu= rep(0,n.var), Sigma=sigma)
  S <- cor(x)
  
  # Calculate gamma values for the proposed method
  gamma <- 1/(1+sum(abs(S - diag(n.var)))/(n.var))
  # Calculate teh proposed estimator of the true covariance matrix
  sigma.gamma = gamma*S + (1-gamma)*diag(n.var)
  
  # Calculate the eigenvalues of all three competing estimators
  MLA.eigen_values <- eigen(sigma.gamma)$values
  eigen_values.shrink <- eigen(cor.shrink(x,verbose = FALSE))$values
  MLE.eigen_values <- eigen(S)$values
  
  eigen.matrix[1,] <- MLE.eigen_values
  eigen.matrix[2,] <- MLA.eigen_values
  eigen.matrix[3,] <- eigen_values.shrink
  eigen.matrix
})
# Average the resulting eigenvalues simulated 1000 times
ave_eigen <- apply(res, c(1,2), mean)
yl <- max(rbind(ave_eigen, e.tre))

pdf(file="FIG4_3e.pdf")
par(mar=c(7,6,2,1), mgp = c(4,1,0))
plot(e.tre, type="b",lwd=3,pch=16,ylim = c(0,yl), xlab="Order",
     ylab = "Eigenvalues", cex.axis=2, yaxt="n", cex.lab=2)
axis(2, las=2, cex.axis=2)
points(ave_eigen[1,], type="b", lwd=3,pch=16 ,col= "20")
points(ave_eigen[2,], type="b", lwd=3,pch=16 ,col= "red")
points(ave_eigen[3,], type="b", lwd=3,pch=16 ,col= "green")
mtext("(e)", side = 3, line = 0.5, cex = 2)

legend("topright", legend = c("True", "MLA", "Shrinkage", "MLE"),
       cex = 1.5,box.lwd = 1,box.lty = 1,
       text.font = 3,col = c("black","red", "green", 20),
       lty = 1, pch = 16)
dev.off()
\end{lstlisting}